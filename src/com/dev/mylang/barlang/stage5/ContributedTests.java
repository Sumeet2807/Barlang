package com.dev.mylang.barlang.stage5;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertIterableEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

import com.dev.mylang.barlang.stage1.CompilerComponentFactory;
import com.dev.mylang.barlang.stage3.ast.IASTNode;
import com.dev.mylang.barlang.stage5.*;
import com.dev.mylang.barlang.stage5.CodeGenUtils.DynamicClassLoader;
public class ContributedTests {
	/** Retrieves value of global int variable from loaded classfile.
		 * 
		 * @param testClass
		 * @param fieldName
		 * @return
		 * @throws Exception
		 */
		static int getInt(Class<?> testClass, String fieldName) throws Exception {
			Field f = testClass.getField(fieldName);
			return f.getInt(null);
		}

		/**
		 * Retrieves value of glboal boolean variable from loaded classfile
		 * 
		 * @param testClass
		 * @param fieldName
		 * @return
		 * @throws Exception
		 */
		static boolean getBoolean(Class<?> testClass, String fieldName) throws Exception {
			Field f = testClass.getField(fieldName);
			return f.getBoolean(null);
		}

		/**
		 * Retrieves value of global String variable from loaded classfile
		 * @param testClass
		 * @param fieldName
		 * @return
		 * @throws Exception
		 */
		static String getString(Class<?> testClass, String fieldName) throws Exception {
			Field f = testClass.getField(fieldName);
			return (String) f.get(null);
		}

		/**
		 * Retrieves value of global List variable from loaded classfile
		 * 
		 * @param testClass
		 * @param listName
		 * @return
		 * @throws Exception
		 */
		static private Iterable<?> getList(Class<?> testClass, String listName) throws Exception {
			Field f = testClass.getField(listName);
			return (Iterable<?>) f.get(null);
		}

		/**
		 * Generates  a classfile for the given source program.  The classfile has the given name and package.
		 * 
		 * @param input
		 * @param className
		 * @param packageName
		 * @return
		 * @throws Exception
		 */
		byte[] compile(String input, String className, String packageName) throws Exception {
			show(input);
			IASTNode ast = CompilerComponentFactory.getParser(input).parse();
			ast.visit(CompilerComponentFactory.getTypeCheckVisitor(), null);
			show(ast);
			byte[] bytecode = (byte[]) ast.visit(CompilerComponentFactory.getCodeGenVisitor(className, packageName, ""), null);
			show(CodeGenUtils.bytecodeToString(bytecode));
			return bytecode;
		}


		/**
		 * Executes indicated method defined in bytecode and returns the result. args is
		 * an Object[] containing the parameters of the method, or may be null if the
		 * method does not have parameters.
		 * 
		 * Requires that the given method is not overloaded in the class file.
		 * 
		 * @param bytecode
		 * @param className
		 * @param methodName
		 * @param args
		 * @return
		 * @throws Exception
		 */
		Object loadClassAndRunMethod(byte[] bytecode, String className, String methodName, Object[] args) throws Exception {
			Class<?> testClass = getClass(bytecode, className);
			return runMethod(testClass,methodName, args);
		}

		private Method findMethod(String name, Method[] methods) {
			for (Method m : methods) {
				String methodName = m.getName();
				if (name.equals(methodName))
					return m;
			}
			throw new RuntimeException("Method " + name + " not found in generated bytecode");
		}

		Class<?> getClass(byte[] bytecode, String className) throws Exception {
			DynamicClassLoader loader = new DynamicClassLoader(Thread.currentThread().getContextClassLoader());
			Class<?> testClass = loader.define(className, bytecode);
			return testClass;
		}


		Object runMethod(Class<?> testClass, String methodName, Object[] args) throws Exception {
			Method[] methods = testClass.getDeclaredMethods();
			Method m = findMethod(methodName, methods);
			return m.invoke(null, args);
		}

		

//		@BeforeAll
//		public static void beforeAll() throws FileNotFoundException {
//			out = new PrintStream(new BufferedOutputStream(new FileOutputStream("hw5Errors.txt")));
//		}
	//
//		@AfterAll
//		public static void afterAll() {
//			out.close();
//		}

		static PrintStream out = System.out;

		static boolean VERBOSE = true;
		void show(Object o) {
			if (VERBOSE) {
				System.out.println(o);
			}
		}

		static final String className = "TestClass";
		static final String packageName = "com.dev.mylang.barlang.tests";
		
		@DisplayName("sumeet_saini_test1")
		@Test
		public void sumeet_saini_test1(TestInfo testInfo) throws Exception {
			String input = """
					VAR x = 10;
					FUN g():STRING
					DO
					IF x/2==5
						DO 
							IF x/5==2
							DO
								RETURN "ten"; 
							END
						END
						RETURN "not ten";
					END
					""";
			byte[] bytecode = compile(input, className, packageName);
			show(CodeGenUtils.bytecodeToString(bytecode));
			String result = (String) loadClassAndRunMethod(bytecode, className, "g", null);
			assertEquals("ten", result);
		}
		
		@DisplayName("sumeet_saini_test2")
		@Test
		public void sumeet_saini_test2(TestInfo testInfo) throws Exception {
			String input = """
					FUN a(i:INT, end:INT, by:INT, in:INT):STRING
					DO
						end = end + in;
						WHILE i < end
						DO
				     		i = i + by;
				     	END
						IF i==end
						DO
							RETURN "EVEN";
						END
						RETURN "ODD";
					END
					""";
			byte[] bytecode = compile(input, className, packageName);
			show(CodeGenUtils.bytecodeToString(bytecode));
			Object[] params = { 0, 5, 2 ,8 };
			String result = (String) loadClassAndRunMethod(bytecode, className, "a", params);
			assertEquals("ODD", result);
		}
		
		@DisplayName("sumeet_saini_test03")
		@Test
		public void sumeet_saini_test03(TestInfo testInfo) throws Exception {
			String input = """
					FUN a(name:STRING,message0:STRING,message1:STRING,i:INT):STRING
					DO
						IF i>0
						DO
							RETURN message0 + name;
						END
						IF i<0
						DO
							RETURN  message1 + name;
						END
						RETURN "no message for value 0";
					END
					""";
			byte[] bytecode = compile(input, className, packageName);
			show(CodeGenUtils.bytecodeToString(bytecode));
			Object[] params = { "sumeet", "Good Morning, ","Good Night, ", 2 };
			String result = (String) loadClassAndRunMethod(bytecode, className, "a", params);
			assertEquals("Good Morning, sumeet", result);
		}
		
		@DisplayName("sumeet_saini_test4")
		@Test
		public void sumeet_saini_test4(TestInfo testInfo) throws Exception {
			String input = """
					VAR end = 64;
					VAR i = 1;
					FUN a(): STRING
					DO
						WHILE i < end
						DO
				     		IF i*i*i == end
				     		DO
				     			RETURN "CUBE";
				     		END
				     		i=i+1;
				     	END
					  	RETURN "NOT CUBE";
					END
					""";
			byte[] bytecode = compile(input, className, packageName);
			show(CodeGenUtils.bytecodeToString(bytecode));
			Object[] params = { };
			String result = (String) loadClassAndRunMethod(bytecode, className, "a", params);
			assertEquals("CUBE", result);
		}
		
		@DisplayName("sumeet_saini_test0")
		@Test
		public void sumeet_saini_test0(TestInfo testInfo) throws Exception {
			String input = """
					FUN g(x:INT): INT
					DO
						RETURN x+1;
					END
					
					FUN main(a:INT,b:INT,c:INT):INT
					DO
						WHILE c<b
						DO
							a = a * c;
							c = g(c);
						END
					   RETURN a;
					END
					""";
			byte[] bytecode = compile(input, className, packageName);
			show(CodeGenUtils.bytecodeToString(bytecode));
			Object[] params = { 1,5,2};
			int result = (int) loadClassAndRunMethod(bytecode, className, "main", params);
			assertEquals(24, result);
		}
}
